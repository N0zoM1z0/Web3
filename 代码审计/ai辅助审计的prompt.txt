åˆå§‹å–‚ï¼š
æŒ‰ä¸‹é¢è¿™ç§å¯¹è¯çš„æ ¼å¼ï¼Œè¿™ç§è¯¦ç»†åº¦ï¼Œè§’åº¦çš„è¦æ±‚ï¼š
çœ‹çœ‹è¿™ä¸ªTokenMapping.sol:

// SPDX-License-Identifier: Apache-2.0



pragma solidity 0.8.20;



import {IRegistryAccess} from "src/interfaces/registry/IRegistryAccess.sol";

import {IRegistryContract} from "src/interfaces/registry/IRegistryContract.sol";

import {ITokenMapping} from "src/interfaces/tokenManager/ITokenMapping.sol";

import {IERC20Metadata} from "openzeppelin-contracts/interfaces/IERC20Metadata.sol";

import {DEFAULT_ADMIN_ROLE, MAX_COLLATERAL_TOKEN_COUNT} from "src/constants.sol";

import {Initializable} from "@openzeppelin/contracts/proxy/utils/Initializable.sol";

import {CheckAccessControl} from "src/utils/CheckAccessControl.sol";



import {

Â  Â  NullAddress, InvalidToken, SameValue, Invalid, TooManyCollateralTokens

} from "src/errors.sol";



/// @title Â  TokenMapping contract

/// @notice Â TokenMapping contract to manage Eth0 collateral tokens and Eth0 tokens.

/// @dev Â  Â  This contract provides functionalities to link Eth0 collateral tokens with ETH0 tokens and manage token pairs.

/// @dev Â  Â  It's part of the Usual Tech team's broader ecosystem to facilitate various operations within the platform.

/// @author Â Usual Tech team

contract TokenMapping is Initializable, ITokenMapping {

Â  Â  using CheckAccessControl for IRegistryAccess;



Â  Â  struct TokenMappingStorageV0 {

Â  Â  Â  Â  /// @notice Immutable instance of the REGISTRY_ACCESS contract for role checks.

Â  Â  Â  Â  IRegistryAccess _registryAccess;

Â  Â  Â  Â  /// @notice Immutable instance of the REGISTRY_CONTRACT for contract interaction.

Â  Â  Â  Â  IRegistryContract _registryContract;

Â  Â  Â  Â  /// @dev track last associated Eth0 collateral token ID associated to ETH0.

Â  Â  Â  Â  uint256 _eth0ToCollateralTokenLastId;

Â  Â  Â  Â  /// @dev assign a Eth0 collateral token address to ETH0 token address.

Â  Â  Â  Â  mapping(address => bool) isEth0Collateral;

Â  Â  Â  Â  /// @dev Â Eth0 collateral token ID associated with ETH0 token address.

Â  Â  Â  Â  // solhint-disable-next-line var-name-mixedcase

Â  Â  Â  Â  mapping(uint256 => address) ETH0CollateralTokens;

Â  Â  }



Â  Â  // keccak256(abi.encode(uint256(keccak256("tokenmapping.storage.v0")) - 1)) & ~bytes32(uint256(0xff))

Â  Â  // solhint-disable-next-line

Â  Â  bytes32 public constant TokenMappingStorageV0Location =

Â  Â  Â  Â  0xb0e2a10694f571e49337681df93856b25ecda603d0f0049769ee36b541ef2300;



Â  Â  /// @notice Returns the storage struct of the contract.

Â  Â  /// @return $ .

Â  Â  function _tokenMappingStorageV0() private pure returns (TokenMappingStorageV0 storage $) {

Â  Â  Â  Â  bytes32 position = TokenMappingStorageV0Location;

Â  Â  Â  Â  // solhint-disable-next-line no-inline-assembly

Â  Â  Â  Â  assembly {

Â  Â  Â  Â  Â  Â  $.slot := position

Â  Â  Â  Â  }

Â  Â  }



Â  Â  /*//////////////////////////////////////////////////////////////

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Constructor

Â  Â  //////////////////////////////////////////////////////////////*/



Â  Â  /// @custom:oz-upgrades-unsafe-allow constructor

Â  Â  constructor() {

Â  Â  Â  Â  _disableInitializers();

Â  Â  }



Â  Â  /// @notice Initializes the TokenMapping contract with registry information.

Â  Â  /// @dev Sets the registry access and contract addresses upon deployment.

Â  Â  /// @param registryAccess The address of the registry access contract.

Â  Â  /// @param registryContract The address of the registry contract.

Â  Â  function initialize(address registryAccess, address registryContract) public initializer {

Â  Â  Â  Â  if (registryAccess == address(0) || registryContract == address(0)) {

Â  Â  Â  Â  Â  Â  revert NullAddress();

Â  Â  Â  Â  }



Â  Â  Â  Â  TokenMappingStorageV0 storage $ = _tokenMappingStorageV0();

Â  Â  Â  Â  $._registryAccess = IRegistryAccess(registryAccess);

Â  Â  Â  Â  $._registryContract = IRegistryContract(registryContract);

Â  Â  }



Â  Â  /// @inheritdoc ITokenMapping

Â  Â  function addEth0CollateralToken(address collateral) external returns (bool) {

Â  Â  Â  Â  if (collateral == address(0)) {

Â  Â  Â  Â  Â  Â  revert NullAddress();

Â  Â  Â  Â  }

Â  Â  Â  Â  // check if there is a decimals function at the address

Â  Â  Â  Â  // and if there is at least 1 decimal

Â  Â  Â  Â  // if not, revert

Â  Â  Â  Â  if (IERC20Metadata(collateral).decimals() == 0) {

Â  Â  Â  Â  Â  Â  revert Invalid();

Â  Â  Â  Â  }



Â  Â  Â  Â  TokenMappingStorageV0 storage $ = _tokenMappingStorageV0();

Â  Â  Â  Â  $._registryAccess.onlyMatchingRole(DEFAULT_ADMIN_ROLE);



Â  Â  Â  Â  // is the collateral token already registered as a ETH0 collateral

Â  Â  Â  Â  if ($.isEth0Collateral[collateral]) revert SameValue();

Â  Â  Â  Â  $.isEth0Collateral[collateral] = true;

Â  Â  Â  Â  // 0 index is always empty

Â  Â  Â  Â  ++$._eth0ToCollateralTokenLastId;

Â  Â  Â  Â  if ($._eth0ToCollateralTokenLastId > MAX_COLLATERAL_TOKEN_COUNT) {

Â  Â  Â  Â  Â  Â  revert TooManyCollateralTokens();

Â  Â  Â  Â  }

Â  Â  Â  Â  $.ETH0CollateralTokens[$._eth0ToCollateralTokenLastId] = collateral;

Â  Â  Â  Â  emit AddEth0CollateralToken(collateral, $._eth0ToCollateralTokenLastId);

Â  Â  Â  Â  return true;

Â  Â  }



Â  Â  /*//////////////////////////////////////////////////////////////

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â View

Â  Â  //////////////////////////////////////////////////////////////*/



Â  Â  /// @inheritdoc ITokenMapping

Â  Â  function getEth0CollateralTokenById(uint256 collateralId) external view returns (address) {

Â  Â  Â  Â  TokenMappingStorageV0 storage $ = _tokenMappingStorageV0();

Â  Â  Â  Â  address collateralToken = $.ETH0CollateralTokens[collateralId];

Â  Â  Â  Â  if (collateralToken == address(0)) {

Â  Â  Â  Â  Â  Â  revert InvalidToken();

Â  Â  Â  Â  }

Â  Â  Â  Â  return collateralToken;

Â  Â  }



Â  Â  /// @inheritdoc ITokenMapping

Â  Â  function getAllEth0CollateralTokens() external view returns (address[] memory) {

Â  Â  Â  Â  TokenMappingStorageV0 storage $ = _tokenMappingStorageV0();

Â  Â  Â  Â  address[] memory collateralTokens = new address[]($._eth0ToCollateralTokenLastId);

Â  Â  Â  Â  // maximum of 10 collateral tokens

Â  Â  Â  Â  uint256 length = $._eth0ToCollateralTokenLastId;

Â  Â  Â  Â  for (uint256 i = 1; i <= length;) {

Â  Â  Â  Â  Â  Â  collateralTokens[i - 1] = $.ETH0CollateralTokens[i];

Â  Â  Â  Â  Â  Â  unchecked {

Â  Â  Â  Â  Â  Â  Â  Â  ++i;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  Â  Â  return collateralTokens;

Â  Â  }



Â  Â  /// @inheritdoc ITokenMapping

Â  Â  function getLastEth0CollateralTokenId() external view returns (uint256) {

Â  Â  Â  Â  TokenMappingStorageV0 storage $ = _tokenMappingStorageV0();

Â  Â  Â  Â  return $._eth0ToCollateralTokenLastId;

Â  Â  }



Â  Â  /// @inheritdoc ITokenMapping

Â  Â  function isEth0Collateral(address collateral) external view returns (bool) {

Â  Â  Â  Â  TokenMappingStorageV0 storage $ = _tokenMappingStorageV0();

Â  Â  Â  Â  return $.isEth0Collateral[collateral];

Â  Â  }

}




Show thinking
å¥½çš„ï¼Œæˆ‘ä»¬æ¥åˆ†æ TokenMapping.sol è¿™ä¸ªåˆçº¦ã€‚

TokenMapping.sol åˆçº¦è¯¦è§£
åˆçº¦ç›®æ ‡ä¸æ ¸å¿ƒåŠŸèƒ½ï¼š ğŸ¯

ETH0 æŠµæŠ¼å“ä»£å¸ç®¡ç†ï¼šæ­¤åˆçº¦çš„æ ¸å¿ƒèŒè´£æ˜¯ç®¡ç†å’Œè¿½è¸ªå“ªäº› ERC20 ä»£å¸è¢«æ‰¹å‡†ä¸ºé“¸é€  ETH0 çš„åˆæ ¼æŠµæŠ¼å“ã€‚
æä¾›æŸ¥è¯¢æ¥å£ï¼šå…è®¸å…¶ä»–åˆçº¦ï¼ˆä¸»è¦æ˜¯ Eth0.sol å’Œå¯èƒ½çš„ DaoCollateral.solï¼‰æŸ¥è¯¢æ”¯æŒçš„æŠµæŠ¼å“åˆ—è¡¨åŠå…¶ç›¸å…³ä¿¡æ¯ã€‚
å¯å‡çº§æ€§ä¸æ ‡å‡†éµå¾ªï¼š
ç»§æ‰¿è‡ª OpenZeppelin çš„ Initializableï¼Œè¡¨æ˜å®ƒæ˜¯ä¸€ä¸ªå¯å‡çº§åˆçº¦çš„é€»è¾‘å®ç°éƒ¨åˆ†ã€‚
ä½¿ç”¨ ERC7201 æ ‡å‡†æ¥å®šä¹‰å…¶å­˜å‚¨ç»“æ„ TokenMappingStorageV0ã€‚
è®¿é—®æ§åˆ¶ï¼šé€šè¿‡ CheckAccessControl å’Œ IRegistryAccess å®ç°åŸºäºè§’è‰²çš„æƒé™ç®¡ç†ï¼Œå…³é”®çš„æ·»åŠ æ“ä½œç”± DEFAULT_ADMIN_ROLE æ§åˆ¶ã€‚
å­˜å‚¨ç»“æ„ (TokenMappingStorageV0) ä¸ä»£ç†å­˜å‚¨æ§½ï¼š

ERC7201 å­˜å‚¨æ¨¡å¼ï¼šä¸ Eth0.sol ç±»ä¼¼ï¼Œä½¿ç”¨ EIP-7201 å®šä¹‰å­˜å‚¨æ§½ã€‚
_registryAccess: ç”¨äºæƒé™æ£€æŸ¥ã€‚
_registryContract: ä¸»æ³¨å†Œè¡¨åˆçº¦ã€‚
_eth0ToCollateralTokenLastId: ä¸€ä¸ªè®¡æ•°å™¨ï¼Œè¿½è¸ªæœ€åä¸€ä¸ªæ·»åŠ çš„æŠµæŠ¼å“ä»£å¸çš„IDã€‚è¿™ä¸ªIDä¼¼ä¹æ˜¯1-indexedçš„ã€‚
isEth0Collateral (mapping(address => bool)): å¿«é€ŸæŸ¥æ‰¾ä¸€ä¸ªä»£å¸åœ°å€æ˜¯å¦ä¸ºå·²æ‰¹å‡†çš„ETH0æŠµæŠ¼å“ã€‚
ETH0CollateralTokens (mapping(uint256 => address)): å°†ä¸€ä¸ªä»1å¼€å§‹çš„IDæ˜ å°„åˆ°å®é™…çš„æŠµæŠ¼å“ä»£å¸åœ°å€ã€‚
å…³é”®å‡½æ•°åˆ†æï¼š

initialize(address registryAccess, address registryContract)

æ ‡å‡†çš„å¯å‡çº§åˆçº¦åˆå§‹åŒ–å‡½æ•°ã€‚
æ£€æŸ¥ä¼ å…¥çš„ registryAccess å’Œ registryContract åœ°å€æ˜¯å¦ä¸ºé›¶åœ°å€ã€‚
å°†è¿™ä¸¤ä¸ªåœ°å€å­˜å…¥åˆçº¦çš„å­˜å‚¨ä¸­ã€‚
addEth0CollateralToken(address collateral)

external å‡½æ•°ï¼Œæƒé™æ§åˆ¶ $._registryAccess.onlyMatchingRole(DEFAULT_ADMIN_ROLE);ï¼Œåªæœ‰æ‹¥æœ‰é»˜è®¤ç®¡ç†å‘˜è§’è‰²çš„åœ°å€æ‰èƒ½è°ƒç”¨ã€‚
åŠŸèƒ½ï¼šæ·»åŠ ä¸€ä¸ªæ–°çš„ ERC20 ä»£å¸ä½œä¸º ETH0 çš„åˆæ ¼æŠµæŠ¼å“ã€‚
æ£€æŸ¥ä¸é€»è¾‘ï¼š
if (collateral == address(0)) { revert NullAddress(); }: ç¡®ä¿æŠµæŠ¼å“åœ°å€ä¸æ˜¯é›¶åœ°å€ã€‚
if (IERC20Metadata(collateral).decimals() == 0) { revert Invalid(); }: é‡è¦æ£€æŸ¥ã€‚è°ƒç”¨æŠµæŠ¼å“ä»£å¸åˆçº¦çš„ decimals() æ–¹æ³•ï¼Œå¹¶ç¡®ä¿å…¶è¿”å›å€¼ä¸ä¸º0ã€‚è¿™æ„å‘³ç€åè®®ä¸æ¥å—é‚£äº›æ²¡æœ‰å°æ•°ä½æ•°ï¼ˆæˆ–è€… decimals() è¿”å›0ï¼‰çš„ä»£å¸ä½œä¸ºæŠµæŠ¼å“ã€‚è¿™é€šå¸¸æ˜¯åˆç†çš„ï¼Œå› ä¸ºå¤§å¤šæ•°æ ‡å‡†çš„ERC20ä»£å¸éƒ½æœ‰å¤§äº0çš„å°æ•°ä½æ•°ã€‚
if ($.isEth0Collateral[collateral]) revert SameValue();: æ£€æŸ¥è¯¥ä»£å¸æ˜¯å¦å·²ç»è¢«æ·»åŠ è¿‡ï¼Œé˜²æ­¢é‡å¤æ·»åŠ ã€‚
$.isEth0Collateral[collateral] = true;: å°†è¯¥ä»£å¸æ ‡è®°ä¸ºåˆæ ¼æŠµæŠ¼å“ã€‚
++$._eth0ToCollateralTokenLastId;: æŠµæŠ¼å“IDè®¡æ•°å™¨åŠ 1ã€‚ç”±äºIDä»1å¼€å§‹ï¼Œç¬¬ä¸€ä¸ªæ·»åŠ çš„ä»£å¸IDå°†æ˜¯1ã€‚
if ($._eth0ToCollateralTokenLastId > MAX_COLLATERAL_TOKEN_COUNT) { revert TooManyCollateralTokens(); }: æ£€æŸ¥å·²æ·»åŠ çš„æŠµæŠ¼å“æ•°é‡æ˜¯å¦è¶…è¿‡äº†é¢„è®¾çš„ä¸Šé™ MAX_COLLATERAL_TOKEN_COUNT (è¿™ä¸ªå¸¸é‡ä» src/constants.sol å¯¼å…¥)ã€‚
$.ETH0CollateralTokens[$._eth0ToCollateralTokenLastId] = collateral;: å°†æ–°çš„æŠµæŠ¼å“IDä¸å…¶åœ°å€å…³è”èµ·æ¥ã€‚
emit AddEth0CollateralToken(collateral, $._eth0ToCollateralTokenLastId);: å‘å‡ºäº‹ä»¶ã€‚
è¯„ä»·ï¼šæ­¤å‡½æ•°çš„æ£€æŸ¥å’Œé€»è¾‘çœ‹èµ·æ¥æ˜¯åˆç†å’Œå®Œå¤‡çš„ï¼Œæœ‰æ•ˆåœ°ç®¡ç†äº†åˆæ ¼æŠµæŠ¼å“åˆ—è¡¨çš„æ·»åŠ è¿‡ç¨‹ã€‚
getEth0CollateralTokenById(uint256 collateralId)

external view å‡½æ•°ã€‚
åŠŸèƒ½ï¼šæ ¹æ®æŠµæŠ¼å“IDï¼ˆä»1å¼€å§‹ï¼‰æŸ¥è¯¢å¯¹åº”çš„æŠµæŠ¼å“ä»£å¸åœ°å€ã€‚
é€»è¾‘ï¼š
address collateralToken = $.ETH0CollateralTokens[collateralId];: ä»æ˜ å°„ä¸­è·å–åœ°å€ã€‚
if (collateralToken == address(0)) { revert InvalidToken(); }: å¦‚æœIDæ— æ•ˆæˆ–æœªè¢«ä½¿ç”¨ï¼ˆæ˜ å°„ä¸­å¯¹åº”çš„å€¼æ˜¯é›¶åœ°å€ï¼Œå› ä¸ºIDæ˜¯ä»1å¼€å§‹åˆ†é…çš„ï¼ŒID 0 ä¸ä¼šè¢«ä½¿ç”¨ï¼‰ï¼Œåˆ™revertã€‚
è¯„ä»·ï¼šç›´æ¥ä¸”æœ‰æ•ˆçš„æŸ¥è¯¢ã€‚
getAllEth0CollateralTokens()

external view å‡½æ•°ã€‚
åŠŸèƒ½ï¼šè¿”å›ä¸€ä¸ªåŒ…å«æ‰€æœ‰å·²æ·»åŠ çš„åˆæ ¼æŠµæŠ¼å“ä»£å¸åœ°å€çš„æ•°ç»„ã€‚
é€»è¾‘ï¼š
address[] memory collateralTokens = new address[]($._eth0ToCollateralTokenLastId);: åˆ›å»ºä¸€ä¸ªé•¿åº¦ä¸ºå½“å‰å·²æ·»åŠ æŠµæŠ¼å“æ•°é‡çš„åŠ¨æ€æ•°ç»„ã€‚
uint256 length = $._eth0ToCollateralTokenLastId;: è·å–å½“å‰æœ€åä¸€ä¸ªIDï¼ˆä¹Ÿå³æŠµæŠ¼å“æ€»æ•°ï¼Œå› ä¸ºIDä»1å¼€å§‹ä¸”è¿ç»­ï¼‰ã€‚
for (uint256 i = 1; i <= length;): å¾ªç¯ä»ID 1åˆ°æœ€åä¸€ä¸ªIDã€‚
collateralTokens[i - 1] = $.ETH0CollateralTokens[i];: å°†ID i å¯¹åº”çš„æŠµæŠ¼å“åœ°å€å­˜å…¥æ•°ç»„çš„ i-1 ä½ç½®ï¼ˆå› ä¸ºæ•°ç»„æ˜¯0-indexedçš„ï¼‰ã€‚
è¯„ä»·ï¼š
é€»è¾‘æ­£ç¡®ï¼Œèƒ½è¿”å›æ‰€æœ‰æŠµæŠ¼å“ã€‚
æ½œåœ¨Gasé—®é¢˜ï¼ˆè½»å¾®ï¼‰ï¼šå¦‚æœ MAX_COLLATERAL_TOKEN_COUNT è®¾ç½®å¾—éå¸¸å¤§ï¼Œå¹¶ä¸”çœŸçš„æ·»åŠ äº†é‚£ä¹ˆå¤šæŠµæŠ¼å“ï¼Œè¿™ä¸ªå‡½æ•°åœ¨è¢«é“¾ä¸Šå…¶ä»–åˆçº¦è°ƒç”¨æ—¶å¯èƒ½ä¼šå› ä¸ºå¤åˆ¶æ•´ä¸ªæ•°ç»„åˆ°å†…å­˜è€Œæ¶ˆè€—è¾ƒå¤šGasã€‚ä½†ä½œä¸º view å‡½æ•°ä¸»è¦ä¾›é“¾ä¸‹æŸ¥è¯¢ï¼Œæˆ–è€…åœ¨é“¾ä¸Šä»…è¢«å°‘æ•°å…³é”®ã€ä½é¢‘çš„åˆçº¦è°ƒç”¨ï¼Œé€šå¸¸æ˜¯å¯ä»¥æ¥å—çš„ã€‚
æ³¨é‡Š // maximum of 10 collateral tokens ä¸å¸¸é‡ MAX_COLLATERAL_TOKEN_COUNT çš„å…³ç³»ï¼šå¦‚æœ MAX_COLLATERAL_TOKEN_COUNT ç¡®å®è¢«å®šä¹‰ä¸º10ï¼ˆåœ¨ constants.sol ä¸­ï¼‰ï¼Œé‚£ä¹ˆè¿™ä¸ªæ³¨é‡Šæ˜¯å‡†ç¡®çš„ã€‚å¦‚æœå¸¸é‡å€¼æ›´å¤§ï¼Œé‚£ä¹ˆè¿™ä¸ªæ³¨é‡Šå¯èƒ½åªæ˜¯ä¸€ä¸ªè¿‡æ—¶çš„ç¤ºä¾‹æˆ–è¯´æ˜ã€‚
getLastEth0CollateralTokenId()

external view å‡½æ•°ã€‚
åŠŸèƒ½ï¼šè¿”å›æœ€åä¸€ä¸ªæ·»åŠ çš„æŠµæŠ¼å“ä»£å¸çš„IDã€‚
é€»è¾‘ï¼šç›´æ¥è¿”å› $._eth0ToCollateralTokenLastIdã€‚
è¯„ä»·ï¼šç®€å•ç›´æ¥ã€‚
isEth0Collateral(address collateral)

external view å‡½æ•°ã€‚
åŠŸèƒ½ï¼šæ£€æŸ¥ç»™å®šçš„ collateral åœ°å€æ˜¯å¦æ˜¯ä¸€ä¸ªå·²æ‰¹å‡†çš„ETH0æŠµæŠ¼å“ã€‚
é€»è¾‘ï¼šç›´æ¥è¿”å› $.isEth0Collateral[collateral] çš„å¸ƒå°”å€¼ã€‚
è¯„ä»·ï¼šé«˜æ•ˆçš„æŸ¥æ‰¾æ–¹æ³•ã€‚
å¯èƒ½å­˜åœ¨çš„é—®é¢˜æˆ–å®¡è®¡æ—¶éœ€è¦æ³¨æ„çš„ç‚¹ï¼š
MAX_COLLATERAL_TOKEN_COUNT çš„å€¼ä¸å®é™…éœ€æ±‚ï¼š

éœ€è¦ç¡®è®¤ constants.sol ä¸­ MAX_COLLATERAL_TOKEN_COUNT çš„å…·ä½“å€¼ã€‚å¦‚æœè¿™ä¸ªå€¼è®¾ç½®å¾—è¿‡å°ï¼Œå¯èƒ½ä¼šä¸å¿…è¦åœ°é™åˆ¶åè®®æœªæ¥æ”¯æŒæ›´å¤šç§ç±»æŠµæŠ¼å“çš„èƒ½åŠ›ã€‚å¦‚æœè®¾ç½®å¾—è¿‡å¤§ï¼Œå¯¹ getAllEth0CollateralTokens() çš„æ½œåœ¨Gaså½±å“ï¼ˆè™½ç„¶ä¸»è¦æ˜¯viewå‡½æ•°ï¼‰ä¹Ÿéœ€è¦è€ƒè™‘ã€‚
æ³¨é‡Šä¸­çš„ "maximum of 10 collateral tokens" éœ€è¦ä¸å¸¸é‡å€¼æ ¸å¯¹ã€‚
å¤–éƒ¨è°ƒç”¨ IERC20Metadata(collateral).decimals() çš„å¯é æ€§ï¼š

åœ¨ addEth0CollateralToken ä¸­ï¼Œä¾èµ–å¤–éƒ¨ä»£å¸åˆçº¦æ­£ç¡®å®ç°å¹¶è¿”å› decimals()ã€‚å¯¹äºç™½åå•ä»£å¸ï¼Œåœ¨æ·»åŠ å‰è¿è¥å›¢é˜Ÿåº”å·²éªŒè¯å…¶åˆè§„æ€§ï¼Œæ‰€ä»¥é£é™©è¾ƒä½ã€‚ä½†å¦‚æœå­˜åœ¨æŸç§æ–¹å¼å¯ä»¥ç»•è¿‡æ­£å¸¸çš„æ·»åŠ æµç¨‹æˆ–æ·»åŠ äº†è¡Œä¸ºå¼‚å¸¸çš„ä»£å¸ï¼Œè¿™é‡Œå¯èƒ½ä¼šå‡ºé—®é¢˜ã€‚
å­˜å‚¨æ§½çš„å›ºå®šæ€§ (ERC7201)ï¼š

ä½¿ç”¨äº† ERC7201 æ ‡å‡†æ¥æŒ‡å®šå­˜å‚¨æ§½ä½ç½®ã€‚è¿™å¯¹äºå¯å‡çº§åˆçº¦æ˜¯æ ‡å‡†åšæ³•ï¼Œä»¥é¿å…å­˜å‚¨å†²çªã€‚å®¡è®¡æ—¶åº”ç¡®è®¤è®¡ç®—æ–¹å¼å’Œå“ˆå¸Œå€¼æ˜¯å¦æ­£ç¡®ï¼ˆè™½ç„¶é€šå¸¸ç”±å·¥å…·ç”Ÿæˆæˆ–ç»è¿‡éªŒè¯ï¼‰ã€‚
æƒé™çš„å•ä¸€æ€§ (DEFAULT_ADMIN_ROLE)ï¼š

æ·»åŠ æŠµæŠ¼å“è¿™ä¸€å…³é”®æ“ä½œä»…ç”± DEFAULT_ADMIN_ROLE æ§åˆ¶ã€‚è¿™æ˜¯ä¸€ç§ä¸­å¿ƒåŒ–æ§åˆ¶ï¼Œå®¡è®¡æŠ¥å‘Šä¸­é€šå¸¸ä¼šæåŠæ­¤ç±»æƒé™çš„é›†ä¸­ç¨‹åº¦ï¼Œå¹¶å»ºè®®è€ƒè™‘å¤šç­¾æˆ–æ—¶é—´é”ç­‰æœºåˆ¶æ¥å¢å¼ºå®‰å…¨æ€§ï¼ˆå°½ç®¡é¡¹ç›®Q&Aä¸­æåˆ° "Owner is trusted"ï¼‰ã€‚
æŠµæŠ¼å“â€œç§»é™¤â€æœºåˆ¶çš„ç¼ºå¤±ï¼š

æ­¤åˆçº¦åªæä¾›äº†æ·»åŠ æŠµæŠ¼å“çš„åŠŸèƒ½ (addEth0CollateralToken)ã€‚
é¡¹ç›®Q&Aä¸­æåˆ°ï¼šâ€œCollateralTokens are not removable by design, they can however be soft-removed by changing their pricefeed / upgrade.â€
è¿™æ„å‘³ç€ä¸€æ—¦ä¸€ä¸ªä»£å¸è¢«æ·»åŠ ä¸ºæŠµæŠ¼å“ï¼Œå®ƒå°±æ°¸ä¹…åœ°å­˜åœ¨äº ETH0CollateralTokens åˆ—è¡¨å’Œ isEth0Collateral æ˜ å°„ä¸­ï¼ˆé™¤éé€šè¿‡åˆçº¦å‡çº§æ¥ä¿®æ”¹å­˜å‚¨ï¼‰ã€‚
â€œè½¯ç§»é™¤â€ (soft-remove) çš„æ¦‚å¿µï¼šé€šè¿‡å°†å…¶ä»·æ ¼é¢„è¨€æœºè®¾ç½®ä¸ºè¿”å›0ä»·æ ¼ï¼Œæˆ–è€…åœ¨ Lendtroller (æˆ–ç­‰æ•ˆçš„é£é™©å‚æ•°åˆçº¦) ä¸­å°†å…¶æŠµæŠ¼å› å­è®¾ç½®ä¸º0ï¼Œå¯ä»¥ä½¿å…¶åœ¨å®é™…ä¸Šä¸èƒ½å†è¢«ç”¨ä½œæ–°çš„æŠµæŠ¼å“ã€‚
å®¡è®¡æ³¨æ„ç‚¹ï¼šéœ€è¦ç¡®è®¤è¿™ç§â€œè½¯ç§»é™¤â€ç­–ç•¥æ˜¯å¦ä¼šåœ¨å…¶ä»–åœ°æ–¹ï¼ˆä¾‹å¦‚ï¼Œåœ¨è®¡ç®—æ€»æŠµæŠ¼ä»·å€¼æ—¶ï¼Œæˆ–åœ¨ç”¨æˆ·å°è¯•ä½¿ç”¨è¿™ç§â€œè½¯ç§»é™¤â€çš„æŠµæŠ¼å“æ—¶ï¼‰äº§ç”Ÿéé¢„æœŸçš„å‰¯ä½œç”¨ã€‚ä¾‹å¦‚ï¼ŒEth0.sol çš„ mint å‡½æ•°åœ¨è®¡ç®— wadCollateralBackingInETH æ—¶ï¼Œä¼šéå† tokenMapping.getAllEth0CollateralTokens()ã€‚å¦‚æœä¸€ä¸ªä»£å¸è¢«â€œè½¯ç§»é™¤â€ï¼ˆä»·æ ¼ä¸º0ï¼‰ï¼Œå®ƒä»ç„¶ä¼šè¢«éå†ï¼Œåªæ˜¯å…¶è´¡çŒ®çš„ä»·å€¼ä¸º0ï¼Œè¿™æ˜¯å¯ä»¥æ¥å—çš„ã€‚ä½†å¦‚æœâ€œè½¯ç§»é™¤â€æ˜¯é€šè¿‡å…¶ä»–æ–¹å¼ï¼ˆä¾‹å¦‚ï¼Œé¢„è¨€æœºåˆçº¦æœ¬èº«revertï¼‰ï¼Œåˆ™å¯èƒ½å¯¼è‡´ mint å‡½æ•°å¤±è´¥ã€‚
æ€»ç»“ï¼š

TokenMapping.sol åˆçº¦çš„é€»è¾‘ç›¸å¯¹ç›´æ¥å’Œæ¸…æ™°ï¼Œä¸»è¦è´Ÿè´£ç»´æŠ¤ä¸€ä¸ªå—ç®¡ç†å‘˜æ§åˆ¶çš„ã€æœ‰æ•°é‡ä¸Šé™çš„ETH0åˆæ ¼æŠµæŠ¼å“åˆ—è¡¨ã€‚å…¶æ ¸å¿ƒåŠŸèƒ½æ˜¯æ·»åŠ å’ŒæŸ¥è¯¢ã€‚

å®¡è®¡æ—¶ä¸»è¦å…³æ³¨ï¼š

MAX_COLLATERAL_TOKEN_COUNT çš„è®¾ç½®åŠå…¶å½±å“ã€‚
å¯¹å¤–éƒ¨ä»£å¸ decimals() è°ƒç”¨çš„ä¾èµ–ã€‚
ç”±äºç¼ºä¹ç¡¬æ€§çš„â€œç§»é™¤æŠµæŠ¼å“â€åŠŸèƒ½ï¼Œéœ€è¦ç†è§£â€œè½¯ç§»é™¤â€ç­–ç•¥åœ¨æ•´ä¸ªåè®®ä¸­çš„ä¸€è‡´æ€§å’Œå½±å“ã€‚
æƒé™ç®¡ç†çš„ä¸­å¿ƒåŒ–ç¨‹åº¦ã€‚
æ€»ä½“è€Œè¨€ï¼Œå¦‚æœå…¶ä¾èµ–çš„å¸¸é‡ï¼ˆå¦‚ MAX_COLLATERAL_TOKEN_COUNTï¼‰å’Œå¤–éƒ¨åˆçº¦ï¼ˆå¦‚ä»£å¸çš„ decimals() å®ç°ã€RegistryAccessï¼‰è¡Œä¸ºç¬¦åˆé¢„æœŸï¼Œæ­¤åˆçº¦æœ¬èº«çš„é€»è¾‘é£é™©è¾ƒä½ã€‚


---
åˆå§‹é¡¹ç›®overviewï¼š

è¿™ä¸ªé¡¹ç›®çš„åŠŸèƒ½ï¼Ÿç‰¹è‰²ï¼ŸåŸºæœ¬é¢ï¼Ÿtokenï¼Œé“¾ï¼Œæœºåˆ¶ï¼Ÿå®¡è®¡æ—¶æœ‰å“ªäº›æ³¨æ„ç‚¹ï¼Ÿå¯èƒ½å­˜åœ¨é—®é¢˜çš„åœ°æ–¹ï¼Ÿ

---

xxx

è¿™ä¸ªä»£ç çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿæœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ
è¯¦ç»†èšé›†æ•´ä½“å’Œæ¯ä¸ªå‡½æ•°
ä¸­æ–‡å›ç­”