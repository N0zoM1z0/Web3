# å‰ç½®çŸ¥è¯†

## AccountInfo

```rust
/// Account information
#[derive(Clone)]
pub struct AccountInfo<'a> {
    /// Public key of the account
    pub key: &'a Pubkey,
    /// Was the transaction signed by this account's public key?
    pub is_signer: bool,
    /// Is the account writable?
    pub is_writable: bool,
    /// The lamports in the account.  Modifiable by programs.
    pub lamports: Rc<RefCell<&'a mut u64>>,
    /// The data held in this account.  Modifiable by programs.
    pub data: Rc<RefCell<&'a mut [u8]>>,
    /// Program that owns this account
    pub owner: &'a Pubkey,
    /// This account's data contains a loaded program (and is now read-only)
    pub executable: bool,
    /// The epoch at which this account will next owe rent
    pub rent_epoch: Epoch,
}
```

## TokenAccount

```rust
/// Account data.
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct Account {
    /// The mint associated with this account
    pub mint: Pubkey,
    /// The owner of this account.
    pub owner: Pubkey,
    /// The amount of tokens this account holds.
    pub amount: u64,
    /// If `delegate` is `Some` then `delegated_amount` represents
    /// the amount authorized by the delegate
    pub delegate: COption<Pubkey>,
    /// The account's state
    pub state: AccountState,
    /// If is_some, this is a native token, and the value logs the rent-exempt reserve. An Account
    /// is required to be rent-exempt, so the value is used by the Processor to ensure that wrapped
    /// SOL accounts do not drop below this threshold.
    pub is_native: COption<u64>,
    /// The amount delegated
    pub delegated_amount: u64,
    /// Optional authority to close the account.
    pub close_authority: COption<Pubkey>,
}
```



## PDA in Solana

> ### Solana ä¸­çš„ PDAï¼ˆProgram Derived Addressï¼‰
>
> #### æ¦‚å¿µ
>
> **PDAï¼ˆProgram Derived Addressï¼Œç¨‹åºæ´¾ç”Ÿåœ°å€ï¼‰** æ˜¯ Solana ä¸­ä¸€ç§ç‰¹æ®Šçš„è´¦æˆ·åœ°å€ï¼Œç”±ç¨‹åºçš„ ID å’Œä¸€ç»„è‡ªå®šä¹‰çš„ `seeds`ï¼ˆç§å­æ•°æ®ï¼‰é€šè¿‡å“ˆå¸Œç®—æ³•ç”Ÿæˆã€‚å…¶æ ¸å¿ƒç‰¹æ€§æ˜¯ï¼š
>
> - **æ— å¯¹åº”ç§é’¥**ï¼šPDA åœ°å€ä¸åœ¨æ¤­åœ†æ›²çº¿ Ed25519 ä¸Šï¼Œæ— æ³•è¢«å¤–éƒ¨ç”¨æˆ·é€šè¿‡ç§é’¥ç­¾åæ§åˆ¶ã€‚
> - **ç¨‹åºè‡ªä¸»æ§åˆ¶**ï¼šåªæœ‰ç”Ÿæˆè¯¥ PDA çš„ç¨‹åºï¼ˆé€šè¿‡ `program_id`ï¼‰å¯ä»¥æ“ä½œå…¶å…³è”çš„è´¦æˆ·ï¼Œå¦‚ç­¾åè·¨ç¨‹åºè°ƒç”¨ï¼ˆCPIï¼‰ã€‚
>
> #### ç”Ÿæˆæ–¹å¼
>
> é€šè¿‡ `find_program_address` å‡½æ•°ç”Ÿæˆï¼ŒåŒ…å«ä»¥ä¸‹æ­¥éª¤ï¼š
>
> 1. **è¾“å…¥å‚æ•°**ï¼š`seeds`ï¼ˆè‡ªå®šä¹‰æ•°æ®ï¼‰ + `program_id`ï¼ˆç¨‹åº IDï¼‰ã€‚
> 2. **å“ˆå¸Œè®¡ç®—**ï¼šä½¿ç”¨ SHA-256 å¯¹ `seeds + program_id` è¿›è¡Œå“ˆå¸Œã€‚
> 3. **éªŒè¯æ›²çº¿**ï¼šè‹¥ç»“æœåœ¨ Ed25519 æ›²çº¿ä¸Šï¼Œè°ƒæ•´ `bump` å€¼ï¼ˆä» 255 é€’å‡ï¼‰é‡æ–°è®¡ç®—ï¼Œç›´åˆ°æ‰¾åˆ°æœ‰æ•ˆçš„ PDAã€‚
>
> #### é‡è¦æ€§
>
> 1. **å®‰å…¨çŠ¶æ€ç®¡ç†** PDA å…è®¸ç¨‹åºè‡ªä¸»ç®¡ç†é“¾ä¸ŠçŠ¶æ€ï¼ˆå¦‚å­˜å‚¨æ•°æ®æˆ–ä»£å¸ï¼‰ï¼Œæ— éœ€ä¾èµ–å¤–éƒ¨è´¦æˆ·çš„ç­¾åï¼Œé¿å…ç§é’¥æ³„éœ²é£é™©ã€‚
> 2. **æƒé™éš”ç¦»**
>    - **ç¨‹åºä¸“å±æ“ä½œ**ï¼šåªæœ‰ç”Ÿæˆ PDA çš„ç¨‹åºèƒ½å¯¹å…¶ç­¾åï¼ˆé€šè¿‡ CPIï¼‰ï¼Œç¡®ä¿æƒé™è¾¹ç•Œæ¸…æ™°ã€‚
>    - **é˜²ç¯¡æ”¹**ï¼šå¤–éƒ¨ç”¨æˆ·æ— æ³•ä¼ªé€  PDA çš„ç­¾åï¼Œä¿éšœåˆçº¦é€»è¾‘å®‰å…¨ã€‚
> 3. **çµæ´»çš„èµ„æºæ§åˆ¶**
>    - **åŠ¨æ€ç”Ÿæˆ**ï¼šé€šè¿‡ä¸åŒ `seeds` ä¸ºæ¯ä¸ªç”¨æˆ·æˆ–åœºæ™¯ç”Ÿæˆç‹¬ç«‹ PDAï¼ˆå¦‚æ¯ä¸ªç”¨æˆ·çš„æ‰˜ç®¡è´¦æˆ·ï¼‰ã€‚
>    - **è·¨ç¨‹åºäº¤äº’**ï¼šç¨‹åºå¯é€šè¿‡ PDA å®‰å…¨è°ƒç”¨å…¶ä»–ç¨‹åºï¼ˆå¦‚ä»£å¸è½¬è´¦ï¼‰ï¼Œæ— éœ€ç”¨æˆ·é€ç¬”ç­¾åã€‚
> 4. **å…¸å‹åº”ç”¨åœºæ™¯**
>    - **ä»£å¸æ‰˜ç®¡**ï¼šæ¯ä¸ªç”¨æˆ·çš„ä»£å¸è´¦æˆ·ç”±ç¨‹åºé€šè¿‡ PDA ç®¡ç†ã€‚
>    - **æµåŠ¨æ€§æ± **ï¼šDEX çš„äº¤æ˜“å¯¹èµ„é‡‘æ± åœ°å€é€šè¿‡ PDA ç”Ÿæˆã€‚
>    - **æƒé™å§”æ‰˜**ï¼šç¨‹åºé€šè¿‡ PDA ä»£è¡¨ç”¨æˆ·æ‰§è¡Œæ‰¹é‡æ“ä½œï¼ˆå¦‚ NFT æ‰¹é‡ä¸Šæ¶ï¼‰ã€‚
>
> #### ä»£ç ç¤ºä¾‹
>
> ```rust
> // ç”Ÿæˆ PDA
> let (pda, bump) = Pubkey::find_program_address(
>     &[b"vault", user.key.as_ref()], // seeds: å›ºå®šå­—ç¬¦ + ç”¨æˆ·åœ°å€
>     program_id
> );
> 
> // ä½¿ç”¨ PDA ç­¾å CPI
> invoke_signed(
>     &transfer_instruction,
>     &[source, destination, pda],
>     &[&[b"vault", user.key.as_ref(), &[bump]]] // ç­¾åæ‰€éœ€çš„ seeds
> );
> ```
>
> ### æ€»ç»“
>
> PDA æ˜¯ Solana æ™ºèƒ½åˆçº¦è®¾è®¡çš„æ ¸å¿ƒæœºåˆ¶ï¼Œé€šè¿‡**ç¨‹åºè‡ªä¸»æ§åˆ¶èµ„æºå’Œæƒé™**ï¼Œè§£å†³äº†**å»ä¸­å¿ƒåŒ–**åº”ç”¨ä¸­çŠ¶æ€ç®¡ç†ã€å®‰å…¨äº¤äº’å’Œæƒé™éš”ç¦»çš„å…³é”®é—®é¢˜ï¼Œæ˜¯æ„å»ºå¤æ‚ DApp çš„åŸºç¡€è®¾æ–½ã€‚

# 0. signer authorization

insecure:

```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");
#[program]
pub mod signer_authorization_insecure {
    use super::*;

    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {
        msg!("GM {}", ctx.accounts.authority.key().to_string());
        Ok(())
    }
}

#[derive(Accounts)]
pub struct LogMessage<'info> {
    authority: AccountInfo<'info>,
}

```

æ„æ€æ˜¯ï¼Œè¿™ä¸ªåœ°æ–¹ï¼š

```rust
pub struct LogMessage<'info> {
    authority: AccountInfo<'info>,
}
```

ç»™authorityçš„æ˜¯AccountInfoï¼Œè€Œæ²¡æœ‰æ ¡éªŒ authority çš„èº«ä»½ã€‚

---

å¯¹æ¯”çœ‹ä¸‹recommendçš„å†™æ³•ï¼š

```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod signer_authorization_recommended {
    use super::*;

    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {
        msg!("GM {}", ctx.accounts.authority.key().to_string());
        Ok(())
    }
}

#[derive(Accounts)]
pub struct LogMessage<'info> {
    authority: Signer<'info>, // <======
}
```

recommendæ˜¯æŠŠæœ€commonçš„AccountInfoæ”¹ä¸ºäº†Signer

---

secureçš„å†™æ³•ï¼Œæ˜¯ä¸ä¾èµ–authorityçš„é‚£ä¸ªçº§åˆ«ï¼Œè€Œæ˜¯åœ¨log_messageå‡½æ•°å†…è¿›è¡Œæƒé™checkï¼š

```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod signer_authorization_secure {
    use super::*;

    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {
        if !ctx.accounts.authority.is_signer { // <=====
            return Err(ProgramError::MissingRequiredSignature);
        }
        msg!("GM {}", ctx.accounts.authority.key().to_string());
        Ok(())
    }
}

#[derive(Accounts)]
pub struct LogMessage<'info> {
    authority: AccountInfo<'info>,
}

```



---

å“¦ï¼Œrecommendæ˜¯æœ€å®‰å…¨çš„å†™æ³•ï¼Œsecureåªæ˜¯æ²¡å¤§çš„å®‰å…¨éšæ‚£ï¼Œä½†æ˜¯ä¹Ÿä¸æ¨èã€‚ã€‚

æ¯”å¦‚dsç»™çš„å¯èƒ½çš„æ¼æ´ç‚¹ï¼š

- **éªŒè¯æ—¶æœºæ»å**ï¼šæ£€æŸ¥å‘ç”Ÿåœ¨æŒ‡ä»¤é€»è¾‘å†…éƒ¨ï¼Œæ”»å‡»è€…å¯èƒ½é€šè¿‡æ„é€ æ¶æ„è¾“å…¥ç»•è¿‡æŸäº›å‰ç½®æ¡ä»¶ã€‚

ä¹‹å‰çœ‹Solanaä¹Ÿä¼šçœ‹åˆ°ä¸€äº›â€œæŒ‡ä»¤é—´ä¼šè¢«æ’å…¥æ¶æ„æŒ‡ä»¤â€çš„è¿™ç§æƒ…å†µï¼ŒğŸ¤”



# 1. account data matching

insecure:

```rust
use anchor_lang::prelude::*;
use anchor_lang::solana_program::program_pack::Pack;
use spl_token::state::Account as SplTokenAccount;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod account_data_matching_insecure {
    use super::*;

    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {
        let token = SplTokenAccount::unpack(&ctx.accounts.token.data.borrow())?;
        msg!("Your account balance is: {}", token.amount);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct LogMessage<'info> {
    token: AccountInfo<'info>,
    authority: Signer<'info>,
}

```

è¿™é‡Œæ˜¯æ²¡æœ‰éªŒè¯è´¦æˆ·çš„çœŸå®æ€§ï¼Œçœ‹recommendçš„ä¿®å¤å°±æ‡‚äº†ï¼šä¹Ÿå°±æ˜¯éªŒè¯è°ƒç”¨è€…æ˜¯ä¸æ˜¯tokençš„owner

ç±»æ¯”solidityï¼š

```solidity
require(msg.sender==token.owner)
// or
modifier onlyOwner()
```

---

```rust
use anchor_lang::prelude::*;
use anchor_spl::token::TokenAccount;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod account_data_matching_recommended {
    use super::*;

    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {
        msg!("Your account balance is: {}", ctx.accounts.token.amount);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct LogMessage<'info> {
    #[account(constraint = authority.key == &token.owner)] // <====
    token: Account<'info, TokenAccount>,
    authority: Signer<'info>,
}

```

æ³¨æ„è¿™é‡Œè¦å–åœ°å€

---

secureçš„å†™æ³•ï¼š

```rust
use anchor_lang::prelude::*;
use anchor_lang::solana_program::program_pack::Pack;
use spl_token::state::Account as SplTokenAccount;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod account_data_matching_secure {
    use super::*;

    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {
        let token = SplTokenAccount::unpack(&ctx.accounts.token.data.borrow())?;
        if ctx.accounts.authority.key != &token.owner {
            return Err(ProgramError::InvalidAccountData);
        }
        msg!("Your acocunt balance is: {}", token.amount);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct LogMessage<'info> {
    token: AccountInfo<'info>,
    authority: Signer<'info>,
}

```



# 2. owner checks

æ„Ÿè§‰å°±æ˜¯è¯´1çš„secureçš„ä¿®å¤å¹¶ä¸å®Œå–„ã€‚

è¿˜éœ€è¦æ£€æŸ¥è¿™ä¸ªï¼šå³è¿™ä¸ªtokenæ˜¯ä¸æ˜¯ä¸€ä¸ªåˆæ³•çš„tokenï¼Œé¿å…åç»­å¯¹spl_tokençš„æ“ä½œå‡ºç°é—®é¢˜ã€‚

```rust
ctx.accounts.token.owner != &spl_token::ID
```

æ‰€ä»¥æœ€å¥½çš„åšæ³•å°±æ˜¯åœ¨structé‚£å„¿æŠŠconstraintå†™å¥½



insecure:

```rust
use anchor_lang::prelude::*;
use anchor_lang::solana_program::program_error::ProgramError;
use anchor_lang::solana_program::program_pack::Pack;
use spl_token::state::Account as SplTokenAccount;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod owner_checks_insecure {
    use super::*;

    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {
        let token = SplTokenAccount::unpack(&ctx.accounts.token.data.borrow())?;
        if ctx.accounts.authority.key != &token.owner {
            return Err(ProgramError::InvalidAccountData);
        }
        msg!("Your account balance is: {}", token.amount);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct LogMessage<'info> {
    token: AccountInfo<'info>,
    authority: Signer<'info>,
}

```



---

recommend:

```rust
use anchor_lang::prelude::*;
use anchor_spl::token::TokenAccount;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod owner_checks_recommended {
    use super::*;

    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {
        msg!("Your account balance is: {}", ctx.accounts.token.amount);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct LogMessage<'info> {
    #[account(constraint = authority.key == &token.owner)]
    token: Account<'info, TokenAccount>,
    authority: Signer<'info>,
}

```





---

secure:

```rust
use anchor_lang::prelude::*;
use anchor_lang::solana_program::program_error::ProgramError;
use anchor_lang::solana_program::program_pack::Pack;
use spl_token::state::Account as SplTokenAccount;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod owner_checks_secure {
    use super::*;

    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {
        let token = SplTokenAccount::unpack(&ctx.accounts.token.data.borrow())?;
        if ctx.accounts.token.owner != &spl_token::ID {
            return Err(ProgramError::InvalidAccountData);
        }
        if ctx.accounts.authority.key != &token.owner {
            return Err(ProgramError::InvalidAccountData);
        }
        msg!("Your account balance is: {}", token.amount);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct LogMessage<'info> {
    token: AccountInfo<'info>,
    authority: Signer<'info>,
}

```

> ### 1. ç¬¬ä¸€ä¸ª `if`ï¼šéªŒè¯ Token è´¦æˆ·çš„ç¨‹åºæ‰€æœ‰è€…
>
> ```rust
> if ctx.accounts.token.owner != &spl_token::ID {
>     return Err(ProgramError::InvalidAccountData);
> }
> ```
>
> #### ğŸ” æ£€æŸ¥ç›®çš„
>
> - **ç¡®ä¿ `token` è´¦æˆ·æ˜¯åˆæ³•çš„ SPL ä»£å¸è´¦æˆ·** éªŒè¯è´¦æˆ·çš„ `owner` å­—æ®µï¼ˆå³è´¦æˆ·çš„æ‰€å±ç¨‹åºï¼‰å¿…é¡»æ˜¯ `spl_token::ID`ï¼ˆSPL ä»£å¸ç¨‹åº IDï¼‰ã€‚ // <==================
>
> #### ğŸ›¡ï¸ é˜²å¾¡çš„æ¼æ´
>
> - **ä¼ªé€ ä»£å¸è´¦æˆ·æ”»å‡»** é˜²æ­¢æ”»å‡»è€…ä¼ å…¥ä¸€ä¸ªé SPL ä»£å¸è´¦æˆ·ï¼ˆå¦‚æ™®é€šç³»ç»Ÿè´¦æˆ·æˆ–å…¶ä»–ç¨‹åºçš„è´¦æˆ·ï¼‰ï¼Œå¯¼è‡´åç»­è§£ææ•°æ®æ—¶å‡ºç°é”™è¯¯æˆ–æ¶æ„æ•°æ®æ³„éœ²ã€‚
>
> ### 2. ç¬¬äºŒä¸ª `if`ï¼šéªŒè¯è°ƒç”¨è€…æƒé™
>
> ```rust
> if ctx.accounts.authority.key != &token.owner {
>     return Err(ProgramError::InvalidAccountData);
> }
> ```
>
> #### ğŸ” æ£€æŸ¥ç›®çš„
>
> - **ç¡®ä¿è°ƒç”¨è€…ï¼ˆ`authority`ï¼‰æ˜¯ä»£å¸è´¦æˆ·çš„åˆæ³•æ‹¥æœ‰è€…** æ¯”è¾ƒç­¾åè€…åœ°å€ï¼ˆ`authority.key`ï¼‰ä¸ä»£å¸è´¦æˆ·æ•°æ®ä¸­è®°å½•çš„æ‹¥æœ‰è€…åœ°å€ï¼ˆ`token.owner`ï¼‰ï¼Œç¡®ä¿ä¸¤è€…ä¸€è‡´ã€‚
>
> #### ğŸ›¡ï¸ é˜²å¾¡çš„æ¼æ´
>
> - **è¶Šæƒè®¿é—®æ”»å‡»** é˜²æ­¢éä»£å¸è´¦æˆ·æ‹¥æœ‰è€…ï¼ˆä¾‹å¦‚å…¶ä»–ç”¨æˆ·ï¼‰é€šè¿‡ä¼ªé€ ç­¾åéæ³•æŸ¥çœ‹ä»–äººä½™é¢ã€‚



# 3. type cosplay

insecure:

ç±»å‹æ··æ·†æ¼æ´ï¼šï¼Ÿ ç±»æ¯”Javaä¸å®‰å…¨çš„ååºåˆ—åŒ–å°±å¯ä»¥ç†è§£äº†ï¼‰

> #### 1. **æ•°æ®ç»“æ„å®šä¹‰**
>
> ```rust
> #[derive(BorshSerialize, BorshDeserialize)]
> pub struct User { authority: Pubkey }
> 
> #[derive(BorshSerialize, BorshDeserialize)]
> pub struct Metadata { account: Pubkey }
> ```
>
> - `User` å’Œ `Metadata` ç»“æ„ä½“éƒ½åŒ…å«ä¸€ä¸ª `Pubkey` ç±»å‹å­—æ®µï¼Œä½†è¯­ä¹‰ä¸åŒã€‚
> - Borsh ååºåˆ—åŒ–æ—¶æŒ‰**å­—æ®µé¡ºåº**è€Œéåç§°è§£ææ•°æ®ã€‚
>
> #### 2. **æ”»å‡»åœºæ™¯**
>
> - æ”»å‡»è€…åˆ›å»ºä¸€ä¸ªMetadata è´¦æˆ·ï¼Œæ•°æ®ä¸ºï¼š
>
>   ```rust
>   Metadata { account: attacker_key }
>   ```
>
> - å°†æ­¤è´¦æˆ·ä½œä¸º `user` å‚æ•°ä¼ å…¥ `update_user` å‡½æ•°ã€‚
>
> - ç¨‹åºè°ƒç”¨ `User::try_from_slice` ååºåˆ—åŒ–æ—¶ï¼Œ`Metadata.account` ä¼šè¢«é”™è¯¯è§£æä¸º `User.authority`ã€‚
>
> - æ­¤æ—¶ `user.authority == attacker_key`ï¼Œè€Œ `authority` ç­¾åä¸ºæ”»å‡»è€…ï¼Œ**ç»•è¿‡æ£€æŸ¥**ã€‚
>
> #### 3. **æ¼æ´æ ¸å¿ƒ**
>
> - **ç¼ºå°‘ç±»å‹æ ‡è¯†ç¬¦**ï¼šæœªåœ¨æ•°æ®ä¸­å­˜å‚¨ç±»å‹æ ‡è®°ï¼ˆå¦‚ `discriminator`ï¼‰ï¼Œæ— æ³•åŒºåˆ† `User` å’Œ `Metadata`ã€‚
> - **ä¾èµ–å­—æ®µé¡ºåºè€Œéè¯­ä¹‰**ï¼šBorsh ååºåˆ—åŒ–æ—¶ä»…æŒ‰å­—æ®µé¡ºåºåŒ¹é…ï¼Œå¯¼è‡´ç±»å‹æ··æ·†ã€‚

```rust
use anchor_lang::prelude::*;
use borsh::{BorshDeserialize, BorshSerialize};

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod type_cosplay_insecure {
    use super::*;

    pub fn update_user(ctx: Context<UpdateUser>) -> ProgramResult {
        let user = User::try_from_slice(&ctx.accounts.user.data.borrow()).unwrap(); // ååºåˆ—åŒ–
        if ctx.accounts.user.owner != ctx.program_id {
            return Err(ProgramError::IllegalOwner);
        }
        if user.authority != ctx.accounts.authority.key() {
            return Err(ProgramError::InvalidAccountData);
        }
        msg!("GM {}", user.authority);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct UpdateUser<'info> {
    user: AccountInfo<'info>,
    authority: Signer<'info>,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct User {
    authority: Pubkey,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct Metadata {
    account: Pubkey,
}

```



---

recommend: ä¸ç”¨Borshååºåˆ—åŒ–

```rust
use anchor_lang::prelude::*;
use borsh::{BorshDeserialize, BorshSerialize};

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod type_cosplay_recommended {
    use super::*;

    pub fn update_user(ctx: Context<UpdateUser>) -> ProgramResult {
        msg!("GM {}", ctx.accounts.user.authority);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct UpdateUser<'info> {
    #[account(has_one = authority)]
    user: Account<'info, User>,
    authority: Signer<'info>,
}

#[account]
pub struct User {
    authority: Pubkey,
}

#[account]
pub struct Metadata {
    account: Pubkey,
}

```

---

secure:

check discriminant

```rust
use anchor_lang::prelude::*;
use borsh::{BorshDeserialize, BorshSerialize};

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod type_cosplay_secure {
    use super::*;

    pub fn update_user(ctx: Context<UpdateUser>) -> ProgramResult {
        let user = User::try_from_slice(&ctx.accounts.user.data.borrow()).unwrap();
        if ctx.accounts.user.owner != ctx.program_id {
            return Err(ProgramError::IllegalOwner);
        }
        if user.authority != ctx.accounts.authority.key() {
            return Err(ProgramError::InvalidAccountData);
        }
        if user.discriminant != AccountDiscriminant::User {
            return Err(ProgramError::InvalidAccountData);
        }
        msg!("GM {}", user.authority);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct UpdateUser<'info> {
    user: AccountInfo<'info>,
    authority: Signer<'info>,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct User {
    discriminant: AccountDiscriminant,
    authority: Pubkey,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct Metadata {
    discriminant: AccountDiscriminant,
    account: Pubkey,
}

#[derive(BorshSerialize, BorshDeserialize, PartialEq)]
pub enum AccountDiscriminant {
    User,
    Metadata,
}

```



# 4. initialization

insecure:

> ####  **æœªæ£€æŸ¥è´¦æˆ·åˆå§‹åŒ–çŠ¶æ€**
>
> ```rust
> pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
>     let mut user = User::try_from_slice(&ctx.accounts.user.data.borrow()).unwrap(); // å‡è®¾è´¦æˆ·å·²åˆå§‹åŒ–
>     user.authority = ctx.accounts.authority.key();
>     // ...
> }
> ```
>
> - **é—®é¢˜**ï¼šç›´æ¥è§£æ `user` è´¦æˆ·æ•°æ®ï¼Œå‡è®¾è¯¥è´¦æˆ·å·²åˆå§‹åŒ–ã€‚æ”»å‡»è€…å¯ä¼ å…¥ **å·²åˆå§‹åŒ–è´¦æˆ·**ï¼Œå¯¼è‡´æ•°æ®è¢«æ„å¤–è¦†ç›–ã€‚
> - **é£é™©**ï¼šæ¶æ„ç”¨æˆ·å¯é€šè¿‡é‡å¤è°ƒç”¨æ­¤æŒ‡ä»¤ç¯¡æ”¹ä»–äººè´¦æˆ·æƒé™ã€‚

```rust
use anchor_lang::prelude::*;
use borsh::{BorshDeserialize, BorshSerialize};
use std::ops::DerefMut;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod initialization_insecure {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
        let mut user = User::try_from_slice(&ctx.accounts.user.data.borrow()).unwrap();

        user.authority = ctx.accounts.authority.key();

        let mut storage = ctx.accounts.user.try_borrow_mut_data()?;
        user.serialize(storage.deref_mut()).unwrap();
        Ok(())
    }
}

/*
- reinitialize
- create and dont initialize
- passing previously initialzed accounts from other programs
  (e.g. token program => need to check delegate and authority)
*/

#[derive(Accounts)]
pub struct Initialize<'info> {
    user: AccountInfo<'info>,
    authority: Signer<'info>,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct User {
    authority: Pubkey,
}

```



---

recommend:

åœ¨ç»“æ„ä½“é‚£å„¿åŠ 

```rust
#[account(init, payer = authority, space = 8+32)]
```



```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod reinitialization_4 {
    use super::*;

    pub fn init(_ctx: Context<Init>) -> ProgramResult {
        msg!("GM");
        Ok(())
    }
}


#[derive(Accounts)]
pub struct Init<'info> {
    #[account(init, payer = authority, space = 8+32)]
    user: Account<'info, User>,
    #[account(mut)]
    authority: Signer<'info>,
    system_program: Program<'info, System>,
}

#[account]
pub struct User {
    authority: Pubkey,
}

```



# 5. arbitary cpi

**æœªç»éªŒè¯çš„è·¨ç¨‹åºè°ƒç”¨ï¼ˆArbitrary CPIï¼‰**

insecure:

> #### 1. **æœªéªŒè¯ `authority` çš„ç­¾åæƒé™**
>
> ```rust
> authority: AccountInfo<'info>, // æœªæ ‡è®°ä¸º Signer
> ```
>
> - **é£é™©**ï¼šæ”»å‡»è€…å¯ä¼ å…¥ä»»æ„ `authority` è´¦æˆ·ï¼ˆæ— éœ€ç­¾åï¼‰ï¼Œä¼ªé€ è½¬è´¦æˆæƒã€‚
> - **åæœ**ï¼šä»»æ„ç”¨æˆ·å¯ç›—å– `source` è´¦æˆ·ä¸­çš„ä»£å¸ã€‚
>
> #### 2. **æœªéªŒè¯ `token_program` èº«ä»½**
>
> ```rust
> token_program: AccountInfo<'info>, // æœªéªŒè¯æ˜¯å¦ä¸º spl_token::ID
> ```
>
> - **é£é™©**ï¼šæ”»å‡»è€…å¯æ›¿æ¢æ¶æ„ä»£å¸ç¨‹åºï¼Œç¯¡æ”¹è½¬è´¦é€»è¾‘ã€‚
> - **åæœ**ï¼šèµ„é‡‘å¯èƒ½è½¬å…¥æ”»å‡»è€…æ§åˆ¶çš„åˆçº¦ã€‚
>
> #### 3. **æœªéªŒè¯ä»£å¸è´¦æˆ·å…³ç³»**
>
> ```rust
> source: AccountInfo<'info>,
> destination: AccountInfo<'info>,
> ```
>
> - é£é™©ï¼š
>   - `source` å¯èƒ½é SPL ä»£å¸è´¦æˆ·ã€‚
>   - `destination` å¯èƒ½å±äºå…¶ä»–ä»£å¸ç±»å‹ï¼ˆmint ä¸åŒ¹é…ï¼‰ã€‚
> - **åæœ**ï¼šæ•°æ®è§£æé”™è¯¯æˆ–èµ„äº§é”™è¯¯è½¬ç§»ã€‚

```rust
use anchor_lang::prelude::*;
use anchor_lang::solana_program;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod arbitrary_cpi_insecure {
    use super::*;

    pub fn cpi(ctx: Context<Cpi>, amount: u64) -> ProgramResult {
        solana_program::program::invoke(
            &spl_token::instruction::transfer(
                ctx.accounts.token_program.key,
                ctx.accounts.source.key,
                ctx.accounts.destination.key,
                ctx.accounts.authority.key,
                &[],
                amount,
            )?,
            &[
                ctx.accounts.source.clone(),
                ctx.accounts.destination.clone(),
                ctx.accounts.authority.clone(),
            ],
        )
    }
}

#[derive(Accounts)]
pub struct Cpi<'info> {
    source: AccountInfo<'info>,
    destination: AccountInfo<'info>,
    authority: AccountInfo<'info>,
    token_program: AccountInfo<'info>,
}

```



---

recommend:

```rust
use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount};

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod arbitrary_cpi_recommended {
    use super::*;

    pub fn cpi(ctx: Context<Cpi>, amount: u64) -> ProgramResult {
        token::transfer(ctx.accounts.transfer_ctx(), amount)
    }
}

#[derive(Accounts)]
pub struct Cpi<'info> {
    source: Account<'info, TokenAccount>,
    destination: Account<'info, TokenAccount>,
    authority: Signer<'info>, // <=== authorityä¸€å®šè¦æ˜¯Signerï¼ï¼ï¼
    token_program: Program<'info, Token>,
}

impl<'info> Cpi<'info> {
    pub fn transfer_ctx(&self) -> CpiContext<'_, '_, '_, 'info, token::Transfer<'info>> {
        let program = self.token_program.to_account_info();
        let accounts = token::Transfer {
            from: self.source.to_account_info(),
            to: self.destination.to_account_info(),
            authority: self.authority.to_account_info(),
        };
        CpiContext::new(program, accounts) // ä½¿ç”¨ Anchor çš„å®‰å…¨ CPI æ–¹æ³•
    }
}

```



# 6. duplicate mutable accounts

insecure:

å­˜åœ¨ **é‡å¤å¯å˜è´¦æˆ·å¼•ç”¨** å’Œ **æœªéªŒè¯è´¦æˆ·å”¯ä¸€æ€§** çš„æ¼æ´ï¼Œ

ä¸»è¦æ˜¯è´¦æˆ·å”¯ä¸€æ€§çš„é—®é¢˜ä¼šå¯¼è‡´Solanaäº¤æ˜“å¤±è´¥

> #### 1. **æœªæ ‡è®°å¯å˜æ€§çº¦æŸ**
>
> ```rust
> #[derive(Accounts)]
> pub struct Update<'info> {
>     user_a: Account<'info, User>, // æœªæ ‡è®° #[account(mut)]
>     user_b: Account<'info, User>,
> }
> ```
>
> - **é—®é¢˜**ï¼š`user_a` å’Œ `user_b` æœªè¢«æ˜ç¡®æ ‡è®°ä¸º `mut`ï¼Œä½†å‡½æ•°å†…å°è¯•ä¿®æ”¹å…¶æ•°æ®ã€‚
> - **Anchor è¡Œä¸º**ï¼šè‹¥æœªæ ‡è®° `mut`ï¼ŒAnchor æ¡†æ¶ä¼šè‡ªåŠ¨æ‹’ç»ä¿®æ”¹æ“ä½œï¼ˆè¿è¡Œæ—¶é”™è¯¯ï¼‰ã€‚
>
> #### 2. **æœªéªŒè¯è´¦æˆ·å”¯ä¸€æ€§**
>
> ```rust
> pub fn update(ctx: Context<Update>, a: u64, b: u64) -> ProgramResult {
>     let user_a = &mut ctx.accounts.user_a; // å¯èƒ½æŒ‡å‘åŒä¸€è´¦æˆ·
>     let user_b = &mut ctx.accounts.user_b;
> 
>     user_a.data = a;
>     user_b.data = b; // è‹¥ user_a == user_bï¼Œå¯¼è‡´é‡å¤ä¿®æ”¹å†²çª
> }
> ```
>
> - **é£é™©**ï¼šè‹¥æ”»å‡»è€…ä¼ å…¥ `user_a` å’Œ `user_b` ä¸ºåŒä¸€è´¦æˆ·ï¼Œä¼šè§¦å‘ Solana è¿è¡Œæ—¶å¯¹ **åŒä¸€è´¦æˆ·å¤šæ¬¡å¯å˜å¼•ç”¨** çš„ç¦æ­¢ï¼Œå¯¼è‡´äº¤æ˜“å¤±è´¥ã€‚

```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod duplicate_mutable_accounts_insecure {
    use super::*;

    pub fn update(ctx: Context<Update>, a: u64, b: u64) -> ProgramResult {
        let user_a = &mut ctx.accounts.user_a;
        let user_b = &mut ctx.accounts.user_b;

        user_a.data = a;
        user_b.data = b;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Update<'info> {
    user_a: Account<'info, User>,
    user_b: Account<'info, User>,
}

#[account]
pub struct User {
    data: u64,
}

```



---

recommend:

```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod duplicate_mutable_accounts_recommended {
    use super::*;

    pub fn update(ctx: Context<Update>, a: u64, b: u64) -> ProgramResult {
        let user_a = &mut ctx.accounts.user_a;
        let user_b = &mut ctx.accounts.user_b;

        user_a.data = a;
        user_b.data = b;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Update<'info> {
    #[account(constraint = user_a.key() != user_b.key())] // <=== avoid duplicated
    user_a: Account<'info, User>,
    user_b: Account<'info, User>,
}

#[account]
pub struct User {
    data: u64,
}

```





# 7. bump seed canonicalization

insecure:

æ¼æ´ç‚¹åœ¨äºå…è®¸ç”¨æˆ·ä¼ å…¥è‡ªå®šä¹‰çš„bumpç”ŸæˆPDAï¼

```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod bump_seed_canonicalization_insecure {
    use super::*;

    pub fn set_value(ctx: Context<BumpSeed>, key: u64, new_value: u64, bump: u8) -> ProgramResult {
        let address =
            Pubkey::create_program_address(&[key.to_le_bytes().as_ref(), &[bump]], ctx.program_id)?;
        if address != ctx.accounts.data.key() {
            return Err(ProgramError::InvalidArgument);
        }

        ctx.accounts.data.value = new_value;

        Ok(())
    }
}

#[derive(Accounts)]
pub struct BumpSeed<'info> {
    data: Account<'info, Data>,
}

#[account]
pub struct Data {
    value: u64,
}

```



---

recommend:

æ­£ç¡®çš„å†™æ³•åº”è¯¥æ˜¯å°†bumpå’Œç”¨æˆ·çš„è´¦æˆ·ç»‘å®š

```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod bump_seed_canonicalization_recommended {
    use super::*;

    pub fn set_value(ctx: Context<BumpSeed>, key: u64, new_value: u64) -> ProgramResult {
        ctx.accounts.data.value = new_value;
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(key: u64)]
pub struct BumpSeed<'info> {
    // Note a subtle pattern that is not displayed here.
    //
    // Usually, the usage of PDAs is broken into two parts:
    //
    // 1) allocation via `#[account(init, seeds = [...], bump)]`
    // 2) using the account via `#[account(init, seeds = [...], bump = data.bump)]
    //
    // When using a PDA, it's usually recommend to store the bump seed in the
    // account data, so that you can use it as demonstrated in 2), which will
    // provide a more efficient check.
    #[account(seeds = [key.to_le_bytes().as_ref()], bump)]
    data: Account<'info, Data>,
}

#[account]
pub struct Data {
    value: u64,
}

```





# 8. pda sharing

insecure:

> #### 1. **PDA ç”Ÿæˆç§å­è¿‡äºç®€å•**
>
> ```rust
> // æ¼æ´ä»£ç ï¼šä»…ç”¨ mint å’Œ bump ç”Ÿæˆ PDA
> let seeds = &[ctx.accounts.pool.mint.as_ref(), &[ctx.accounts.pool.bump]];
> ```
>
> - **é—®é¢˜**ï¼š`TokenPool` çš„ PDA ä»…åŸºäº `mint` å’Œ `bump` ç”Ÿæˆï¼Œè‹¥å¤šä¸ª `TokenPool` è´¦æˆ·å…±äº«ç›¸åŒçš„ `mint` å’Œ `bump`ï¼Œåˆ™å®ƒä»¬çš„ PDA å°†**æŒ‡å‘åŒä¸€ä¸ªåœ°å€**ã€‚
> - **åæœ**ï¼šæ”»å‡»è€…å¯åˆ›å»ºæ–° `TokenPool` å¤ç”¨ç›¸åŒ `mint` å’Œ `bump`ï¼Œä»è€Œæ§åˆ¶åŒä¸€ PDA æƒé™ï¼Œç›—å–å…¶ä»–æ± çš„èµ„é‡‘ã€‚
>
> #### 2. **ç¼ºä¹å”¯ä¸€æ€§çº¦æŸ**
>
> ```rust
> #[account]
> pub struct TokenPool {
>     vault: Pubkey,
>     mint: Pubkey,           // å¯èƒ½é‡å¤
>     withdraw_destination: Pubkey,
>     bump: u8,               // å¯èƒ½é‡å¤
> }
> ```
>
> - **é£é™©**ï¼š`mint` å’Œ `bump` çš„ç»„åˆä¸å…·å¤‡å”¯ä¸€æ€§ï¼Œæ”»å‡»è€…å¯ä¼ªé€ ç›¸åŒå‚æ•°çš„ `TokenPool`ã€‚
>
> #### 3. **ç­¾åæƒé™æ³›åŒ–**
>
> ```rust
> token::transfer(ctx.accounts.transfer_ctx().with_signer(&[seeds]))
> ```
>
> - **é—®é¢˜**ï¼šæ‰€æœ‰ç¬¦åˆ `mint` å’Œ `bump` æ¡ä»¶çš„ PDA å‡æœ‰æƒç­¾ç½²è½¬è´¦ï¼Œå¯¼è‡´è¶Šæƒæ“ä½œã€‚

```rust
use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount};

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod pda_sharing_insecure {
    use super::*;

    pub fn withdraw_tokens(ctx: Context<WithdrawTokens>) -> ProgramResult {
        let amount = ctx.accounts.vault.amount;
        let seeds = &[ctx.accounts.pool.mint.as_ref(), &[ctx.accounts.pool.bump]];
        token::transfer(ctx.accounts.transfer_ctx().with_signer(&[seeds]), amount)
    }
}

#[derive(Accounts)]
pub struct WithdrawTokens<'info> {
    #[account(has_one = vault, has_one = withdraw_destination)]
    pool: Account<'info, TokenPool>,
    vault: Account<'info, TokenAccount>,
    withdraw_destination: Account<'info, TokenAccount>,
    authority: Signer<'info>,
    token_program: Program<'info, Token>,
}

impl<'info> WithdrawTokens<'info> {
    pub fn transfer_ctx(&self) -> CpiContext<'_, '_, '_, 'info, token::Transfer<'info>> {
        let program = self.token_program.to_account_info();
        let accounts = token::Transfer {
            from: self.vault.to_account_info(),
            to: self.withdraw_destination.to_account_info(),
            authority: self.authority.to_account_info(),
        };
        CpiContext::new(program, accounts)
    }
}

#[account]
pub struct TokenPool {
    vault: Pubkey,
    mint: Pubkey,
    withdraw_destination: Pubkey,
    bump: u8,
}

```





---

recommend:

```rust
use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount};

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod pda_sharing_recommended {
    use super::*;

    pub fn withdraw_tokens(ctx: Context<WithdrawTokens>) -> ProgramResult {
        let amount = ctx.accounts.vault.amount;
        let seeds = &[
            ctx.accounts.pool.withdraw_destination.as_ref(),
            &[ctx.accounts.pool.bump],
        ];
        token::transfer(ctx.accounts.transfer_ctx().with_signer(&[seeds]), amount)
    }
}

#[derive(Accounts)]
pub struct WithdrawTokens<'info> {
    #[account(
				has_one = vault,
				has_one = withdraw_destination,
				seeds = [withdraw_destination.key().as_ref()], // <=== å”¯ä¸€æ€§çº¦æŸ
				bump = pool.bump,  // <=== éªŒè¯æ­£ç¡® bump
		)]
    pool: Account<'info, TokenPool>,
    vault: Account<'info, TokenAccount>,
    withdraw_destination: Account<'info, TokenAccount>,
    authority: Signer<'info>,
    token_program: Program<'info, Token>,
}

impl<'info> WithdrawTokens<'info> {
    pub fn transfer_ctx(&self) -> CpiContext<'_, '_, '_, 'info, token::Transfer<'info>> {
        let program = self.token_program.to_account_info();
        let accounts = token::Transfer {
            from: self.vault.to_account_info(),
            to: self.withdraw_destination.to_account_info(),
            authority: self.authority.to_account_info(),
        };
        CpiContext::new(program, accounts)
    }
}

#[account]
pub struct TokenPool {
    vault: Pubkey,
    mint: Pubkey,
    withdraw_destination: Pubkey,
    bump: u8,
}

```



# 9. closing accounts

insecureï¼š

è¯¥ä»£ç å­˜åœ¨ **è´¦æˆ·å…³é—­ä¸å®Œæ•´** å’Œ **æƒé™æ§åˆ¶ç¼ºå¤±** çš„æ¼æ´

> #### 1. **æœªæ¸…é™¤è´¦æˆ·æ•°æ®**
>
> ```rust
> // ä»…è½¬ç§» lamportsï¼Œæœªæ¸…ç©ºæ•°æ®
> **ctx.accounts.account.to_account_info().lamports.borrow_mut() = 0;
> ```
>
> - **é—®é¢˜**ï¼šè´¦æˆ·çš„ `data` å­—æ®µæœªè¢«æ¸…ç©ºï¼Œæ”»å‡»è€…å¯é€šè¿‡é‡æ”¾äº¤æ˜“æ“ä½œæ®‹ç•™æ•°æ®ã€‚
> - **é£é™©**ï¼šè´¦æˆ·åœ¨ lamports å½’é›¶åä»ä¿ç•™æ•°æ®ï¼Œå¯èƒ½è¢«è¯¯è®¤ä¸ºæœ‰æ•ˆçŠ¶æ€ã€‚
>
> #### 2. **æœªéªŒè¯å…³é—­æƒé™**
>
> ```rust
> #[derive(Accounts)]
> pub struct Close<'info> {
>     account: Account<'info, Data>, // æœªéªŒè¯å…³é—­æƒé™
>     destination: AccountInfo<'info>, // æœªéªŒè¯æ¥æ”¶è€…èº«ä»½
> }
> ```
>
> - **é£é™©**ï¼šä»»ä½•ç”¨æˆ·éƒ½å¯è°ƒç”¨æ­¤æŒ‡ä»¤å…³é—­ä»–äººè´¦æˆ·ï¼Œå¯¼è‡´èµ„é‡‘çªƒå–æˆ–æ•°æ®ä¸¢å¤±ã€‚
>
> #### 3. **æœªæ ‡è®°è´¦æˆ·å…³é—­çŠ¶æ€**
>
> - **é—®é¢˜**ï¼šæœªè°ƒç”¨ Solana ç³»ç»ŸæŒ‡ä»¤ `close_account`ï¼Œè´¦æˆ·æœªè¢«æ ‡è®°ä¸ºã€Œå·²å…³é—­ã€ï¼Œå¯èƒ½è¢«é‡å¤æ“ä½œã€‚

```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod closing_accounts_insecure {
    use super::*;

    pub fn close(ctx: Context<Close>) -> ProgramResult {
        let dest_starting_lamports = ctx.accounts.destination.lamports();

        **ctx.accounts.destination.lamports.borrow_mut() = dest_starting_lamports
            .checked_add(ctx.accounts.account.to_account_info().lamports())
            .unwrap();
        **ctx.accounts.account.to_account_info().lamports.borrow_mut() = 0;

        Ok(())
    }
}

#[derive(Accounts)]
pub struct Close<'info> {
    account: Account<'info, Data>,
    destination: AccountInfo<'info>,
}

#[account]
pub struct Data {
    data: u64,
}

```



---

recommend:

```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod closing_accounts_recommended {
    use super::*;

    pub fn close(ctx: Context<Close>) -> ProgramResult {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Close<'info> {
    #[account(mut, close = destination)] // è‡ªåŠ¨è½¬ç§» lamports å¹¶æ ‡è®°å…³é—­
    account: Account<'info, Data>,
    #[account(mut)]
    destination: Signer<'info>,
}

#[account]
pub struct Data {
    data: u64,
}

```





# 10. sysvar address check

insecure:

> #### 1. **æœªéªŒè¯ Sysvar è´¦æˆ·åœ°å€**
>
> ```rust
> #[derive(Accounts)]
> pub struct CheckSysvarAddress<'info> {
>     rent: AccountInfo<'info>, // æœªéªŒè¯æ˜¯å¦ä¸ºåˆæ³•çš„ Sysvar è´¦æˆ·
> }
> ```
>
> - **é—®é¢˜**ï¼š`rent` è´¦æˆ·æœªéªŒè¯å…¶åœ°å€æ˜¯å¦ä¸º Solana å®˜æ–¹ Rent Sysvar åœ°å€ï¼ˆ`SysvarRent111111111111111111111111111111111`ï¼‰ã€‚
> - **é£é™©**ï¼šæ”»å‡»è€…å¯ä¼ å…¥ä¼ªé€ è´¦æˆ·ï¼Œå¯¼è‡´ç¨‹åºè¯»å–é”™è¯¯æ•°æ®ï¼Œç ´åé€»è¾‘å®‰å…¨æ€§ã€‚
>
> #### 2. **ä¾èµ–ä¸å¯ä¿¡æ•°æ®**
>
> ```rust
> msg!("Rent Key -> {}", ctx.accounts.rent.key().to_string());
> ```
>
> - **åæœ**ï¼šè‹¥ `rent` è´¦æˆ·è¢«ä¼ªé€ ï¼Œæ—¥å¿—è¾“å‡ºé”™è¯¯åœ°å€ï¼Œè¯¯å¯¼è°ƒè¯•æˆ–ç›‘æ§ã€‚

```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod insecure {
    use super::*;

    pub fn check_sysvar_address(ctx: Context<CheckSysvarAddress>) -> Result<()> {
        msg!("Rent Key -> {}", ctx.accounts.rent.key().to_string());
        Ok(())
    }
}

#[derive(Accounts)]
pub struct CheckSysvarAddress<'info> {
    rent: AccountInfo<'info>,
}

```



---

recommend:

```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod recommended {
    use super::*;

    pub fn check_sysvar_address(ctx: Context<CheckSysvarAddress>) -> Result<()> {
        msg!("Rent Key -> {}", ctx.accounts.rent.key().to_string());
        Ok(())
    }
}

#[derive(Accounts)]
pub struct CheckSysvarAddress<'info> {
    rent: Sysvar<'info, Rent>, // <===
}

```



